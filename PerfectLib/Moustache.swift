//
//  Moustache.swift
//  PerfectLib
//
//  Created by Kyle Jessup on 7/7/15.
//
//

import Foundation
import ICU

let MOUSTACHE_EXTENSION = "moustache"

enum MoustacheTagType {
	
	case Plain // plain text
	case Tag // some tag. not sure which yet
	case Hash
	case Slash
	case Amp
	case Caret
	case Bang
	case Partial
	case Delims
	case UnescapedName
	case Name
	case UnencodedName
	case Pragma
	case None
	
}

/// This enum type represents the parsing and the runtime evaluation exceptions which may be generated.
public enum MoustacheError : ErrorType {
	case SyntaxError(String)
	case EvaluationError(String)
}

/// This class represents an individual scope for moustache template values.
/// A moustache template handler will return a `MoustacheEvaluationContext.MapType` object as a result from its `PageHandler.valuesForResponse` function.
public class MoustacheEvaluationContext {
	
	public typealias MapType = Dictionary<String, Any>
	public typealias SequenceType = Array<MapType>
	
	/// The parent of this context
	public var parent: MoustacheEvaluationContext? = nil
	/// Provides access to the current WebResponse object
	public weak var webResponse: WebResponse?
	/// Provides access to the current WebRequest object
	public var webRequest: WebRequest? {
		if let w = self.webResponse {
			return w.request
		}
		return nil
	}
	
	
	/// Complete path to the file being processed
	/// Potentially nil in cases of dynamic file generation(?)
	public var filePath: String?
	
	public var templateName: String {
		let nam = filePath?.lastPathComponent ?? ""
		return nam
	}
	
	var mapValues: MapType
	
	internal init(webResponse: WebResponse?) {
		self.webResponse = webResponse
		mapValues = MapType()
	}
	
	internal init(webResponse: WebResponse?, map: MapType) {
		self.webResponse = webResponse
		mapValues = map
	}
	
	public init(map: MapType) {
		self.webResponse = nil
		mapValues = map
	}
	
	internal func newChildContext() -> MoustacheEvaluationContext {
		let cc = MoustacheEvaluationContext(webResponse: webResponse)
		cc.parent = self
		return cc
	}
	
	internal func newChildContext(withMap: MapType) -> MoustacheEvaluationContext {
		let cc = MoustacheEvaluationContext(webResponse: webResponse, map: withMap)
		cc.parent = self
		return cc
	}
	
	/// Search for a value starting from the current context. If not found in the current context, the parent context will be searched, etc.
	/// - parameter named: The name of the value to find
	/// - returns: The value, if found, or nil
	public func getValue(named: String) -> MapType.Value? {
		let v = mapValues[named]
		if v == nil && parent != nil {
			return parent?.getValue(named)
		}
		return v
	}
	
	/// Extends the current values with those from the parameter.
	/// - parameter with: The new values to add
	public func extendValues(with: MapType) {
		for (key, value) in with {
			mapValues[key] = value
		}
	}
	
	func getCurrentFilePath() -> String? {
		if self.filePath != nil {
			return self.filePath!
		}
		if self.parent != nil {
			return self.parent!.getCurrentFilePath()
		}
		return nil
	}
}

/// An instance of this class will collect all output data generated by moustache tags during evaluation.
/// Call the `asString()` function to retreive the resulting data.
public class MoustacheEvaluationOutputCollector {
	var output = [String]()
	
	var defaultEncodingFunc: (String) -> String = { $0.stringByEncodingHTML }
	
	public init() {
		
	}
	
	/// Append a new string value to the collected output.
	/// - parameter s: The string value which will be appended.
	/// - parameter encoded: If true, the string value will be HTML encoded as it is appended. Defaults to true.
	public func append(s: String, encoded: Bool = true) -> MoustacheEvaluationOutputCollector {
		if encoded {
			output.append(self.defaultEncodingFunc(s))
		} else {
			output.append(s)
		}
		return self
	}
	
	/// Joins all the collected output into one string and returns this value.
	public func asString() -> String {
		return output.joinWithSeparator("")
	}
}

/// An individual moustache tag or plain-text section
public class MoustacheTag {
	var type = MoustacheTagType.None
	var tag = ""
	weak var parent: MoustacheGroupTag?
	
	// only used for debug purposes
	var openD: [UnicodeScalar]?
	var closeD: [UnicodeScalar]?
	
	/// Evaluate the tag within the given context.
	public func evaluate(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		
		switch type {
		case .Plain:
			collector.append(tag, encoded: false)
		case .UnescapedName:
			collector.append(tag, encoded: false)
		case .Name:
			if let value = context.getValue(tag) {
				collector.append(String(value))
			}
		case .UnencodedName:
			if let value = context.getValue(tag) {
				collector.append(String(value), encoded: false)
			}
		case .Pragma, .Bang:
			() // ignored
		default:
			print("Unhandled moustache tag type \(type)")
		}
	}
	
	func delimOpen() -> String {
		var s = "".unicodeScalars
		s.appendContentsOf(openD!)
		return String(s)
	}
	
	func delimClose() -> String {
		var s = "".unicodeScalars
		s.appendContentsOf(closeD!)
		return String(s)
	}
	
	/// Reconstitutes the tag into its original source string form.
	/// - returns: The resulting string, including the original delimiters and tag-type marker.
	public func description() -> String {
		
		guard type != .Plain else {
			return tag
		}
		
		var s = delimOpen()
		switch type {
		case .Name:
			s.appendContentsOf(" ")
		case .UnencodedName:
			s.appendContentsOf("{ ")
		case .Hash:
			s.appendContentsOf("# ")
		case .Caret:
			s.appendContentsOf("^ ")
		case .Bang:
			s.appendContentsOf("! ")
		case .Partial:
			s.appendContentsOf("> ")
		case .UnescapedName:
			s.appendContentsOf("& ")
		case .Pragma:
			s.appendContentsOf("% ")
		default:
			()
		}
		s.appendContentsOf(tag)
		if type == .UnencodedName {
			s.appendContentsOf(" }" + delimClose())
		} else {
			s.appendContentsOf(" " + delimClose())
		}
		return s
	}
}

/// A sub-class of MoustacheTag which represents a moustache "partial" tag.
public class MoustachePartialTag : MoustacheTag {
	
	public override func evaluate(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		
		guard let page = context.getCurrentFilePath() else {
			print("Exception while executing partial \(tag): unable to find template root directory")
			return
		}
		
		let pageDir = page.stringByDeletingLastPathComponent
		let fullPath = pageDir + "/" + self.tag + "." + MOUSTACHE_EXTENSION
		
		let file = File(fullPath)
		guard file.exists() else {
			print("Exception while executing partial \(tag): file not found")
			return
		}
		do {
			try file.openRead()
			defer { file.close() }
			let bytes = try file.readSomeBytes(file.size())
			
			// !FIX! cache parsed moustache files
			// check mod dates for recompilation
			
			let parser = MoustacheParser()
			let str = UTF8Encoding.encode(bytes)
			let template = try parser.parse(str)
			
			try template.evaluatePragmas(context, collector: collector, requireHandler: false)
			
			let newContext = context.newChildContext()
			newContext.filePath = fullPath
			template.evaluate(newContext, collector: collector)
			
		} catch let e {
			print("Exception while executing partial \(tag): \(e)")
		}
	}
}

/// A sub-class of MoustacheTag which represents a pragma tag.
/// Pragma tags are "meta" tags which influence template evaluation but likely do not output any data.
public class MoustachePragmaTag : MoustacheTag {
	
	// A:B,C:D,E,F:G
	public func parsePragma() -> Dictionary<String, String> {
		var d = Dictionary<String, String>()
		let commaSplit = tag.characters.split() { $0 == Character(",") }.map { String($0) }
		for section in commaSplit {
			let colonSplit = section.characters.split() { $0 == Character(":") }.map { String($0) }
			if colonSplit.count == 1 {
				d[colonSplit[0]] = ""
			} else if colonSplit.count > 1 {
				d[colonSplit[0]] = colonSplit[1]
			}
		}
		return d
	}
	
}

/// A sub-class of MoustacheTag which represents a group of child tags.
public class MoustacheGroupTag : MoustacheTag {
	var children = [MoustacheTag]()
	
	func evaluatePos(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		let cValue = context.getValue(tag)
		if let value = cValue {
			// if it is a dictionary, then eval children with it as the new context
			// otherwise, it must be an array with elements which are dictionaries
			switch value {
			case let v as MoustacheEvaluationContext.MapType:
				let newContext = context.newChildContext(v)
				for child in children {
					child.evaluate(newContext, collector: collector)
				}
			case let v as [String:String]:
				let newContext = context.newChildContext(v)
				for child in children {
					child.evaluate(newContext, collector: collector)
				}
			case let sequence as MoustacheEvaluationContext.SequenceType:
				for item in sequence {
					let newContext = context.newChildContext(item)
					for child in children {
						child.evaluate(newContext, collector: collector)
					}
				}
			case let lambda as (String, MoustacheEvaluationContext) -> String:
				collector.append(lambda(bodyText(), context), encoded: false)
			case let stringValue as String where stringValue.characters.count > 0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let booleanValue as Bool where booleanValue == true:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let intValue as Int where intValue != 0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let decValue as Double where decValue != 0.0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			default:
				()
			}
		}
	}

	func evaluateNeg(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		let cValue = context.getValue(tag)
		if let value = cValue {
			switch value {
			case let v as MoustacheEvaluationContext.MapType where v.count == 0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let v as [String:String] where v.count == 0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let sequence as MoustacheEvaluationContext.SequenceType where sequence.count == 0:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			case let booleanValue as Bool where booleanValue == false:
				for child in children {
					child.evaluate(context, collector: collector)
				}
			default:
				()
			}
		} else {
			for child in children {
				child.evaluate(context, collector: collector)
			}
		}
	}
	
	public override func evaluate(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		if type == .Hash {
			self.evaluatePos(context, collector: collector)
		} else if type == .Caret {
			self.evaluateNeg(context, collector: collector)
		} else {
			// optionally a warning?
			// otherwise this is a perfectly valid situation
		}
	}
	
	func bodyText() -> String {
		var s = ""
		for child in children {
			s.appendContentsOf(child.description())
		}
		return s
	}
	
	override public func description() -> String {
		var s = super.description()
		for child in children {
			s.appendContentsOf(child.description())
		}
		s.appendContentsOf(delimOpen() + "/ " + tag + " " + delimClose())
		return s
	}
}

/// This class represents a moustache template which has been parsed and is ready to evaluate.
/// It contains a series of "out of band" pragmas which can influence the evaluation, and a 
/// series of children which constitute the body of the template itself.
public class MoustacheTemplate : MoustacheGroupTag {
	
	var pragmas = [MoustachePragmaTag]()
	var templateName: String = ""
	/// Evaluate any pragmas which were found in the template. These pragmas may alter the given `MoustacheEvaluationContext` parameter.
	/// - parameter context: The `MoustacheEvaluationContext` object which will be used to further evaluate the template.
	/// - parameter collector: The `MoustacheEvaluationOutputCollector` object which will collect all output from the template evaluation.
	/// - parameter requireHandler: If true, the pragmas must contain a PageHandler pragma which must indicate a previously registered handler object. If a global page handler has been registered then it will be utilized. If `requireHandler` is false, the global handler will NOT be sought.
	/// - throws: If `requireHandler` is true and the a handler pragma does not exist or does not indicate a properly registered handler object, then this function will throw `MoustacheError.EvaluationError`.
	public func evaluatePragmas(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector, requireHandler: Bool = true) throws {
		
		var foundHandler = false
		
		for pragma in pragmas {
			let d = pragma.parsePragma()
			if let handler = d["handler"] {
				if let handler = PageHandlerRegistry.getPageHandler(handler, forResponse: context.webResponse!) {
					foundHandler = true
					let values = try handler.valuesForResponse(context, collector: collector)
					context.extendValues(values)
				}
			}
		}
		
		if requireHandler && !foundHandler {
			if let handler = PageHandlerRegistry.getPageHandler(context.webResponse!) {
				foundHandler = true
				let values = try handler.valuesForResponse(context, collector: collector)
				context.extendValues(values)
			}
		}
		
		if requireHandler && !foundHandler {
			throw MoustacheError.EvaluationError("No valid PageHandler was specified in the template's pragmas.")
		}
	}
	
	/// Evaluate the template using the given context and output collector.
	/// - parameter context: The `MoustacheEvaluationContext` object which holds the values used for evaluating the template.
	/// - parameter collector: The `MoustacheEvaluationOutputCollector` object which will collect all output from the template evaluation. `MoustacheEvaluationOutputCollector.asString()` can be called to retreive the resulting output data.
	override public func evaluate(context: MoustacheEvaluationContext, collector: MoustacheEvaluationOutputCollector) {
		for child in children {
			child.evaluate(context, collector: collector)
		}
		context.webResponse = nil
	}
	
	override public func description() -> String {
		var s = ""
		for child in children {
			s.appendContentsOf(child.description())
		}
		return s
	}
}

/// This object will parse templates written in the moustache markup language.
/// Calling `parse` with the path to a file will return the resulting parsed and ready to evaluate template.
public class MoustacheParser {
	
	var activeList: MoustacheGroupTag?
	var pragmas = [MoustachePragmaTag]()
	var openDelimiters: [UnicodeScalar] = ["{", "{"]
	var closeDelimiters: [UnicodeScalar] = ["}", "}"]
	var handlingUnencodedName = false
	var testingPutback: String?
	
	typealias UGen = String.UnicodeScalarView.Generator
	
	var g: UGen?
	var offset = -1
	
	public init() {
		
	}
	
	/// Parses a string containing moustache markup and returns the `MoustacheTemplate` object.
	/// - throws: `MoustacheError.SyntaxError`
	/// - returns: A `MoustacheTemplate` object which can be evaluated.
	public func parse(string: String) throws -> MoustacheTemplate {
		
		let t = MoustacheTemplate()
		self.activeList = t
		self.g = string.unicodeScalars.generate()
		
		try consumeLoop()
		
		t.pragmas = pragmas
		
		return t
	}
	
	func next() -> UnicodeScalar? {
		offset += 1
		return g!.next()
	}
	
	func consumeLoop() throws {
		var type = MoustacheTagType.Plain
		repeat {
			type = try consumeType(type)
			// just loop it
		} while type != .None
	}
	
	func consumeType(t: MoustacheTagType) throws -> MoustacheTagType {
		switch t {
		case .Plain:
			return consumePlain()
		case .Tag:
			return try consumeTag()
		default:
			throw MoustacheError.SyntaxError("Bad parsing logic in consumeType \(t)")
		}
	}
	
	func addChild(t: MoustacheTag) {
		self.activeList!.children.append(t)
		t.parent = self.activeList!
		
		t.openD = openDelimiters
		t.closeD = closeDelimiters
	}
	
	// Read until delimiters are encountered
	func consumePlain() -> MoustacheTagType {
		
		let currTag = MoustacheTag()
		currTag.type = .Plain
		
		addChild(currTag)
		
		while true {
			guard let e = next() else {
				return .None
			}
			
			if e == openDelimiters[0] {
				testingPutback = String(e)
				if consumePossibleOpenDelimiter(1) {
					return .Tag
				}
				currTag.tag.appendContentsOf(testingPutback!)
			} else {
				currTag.tag.append(e)
			}
		}
	}
	
	func consumePossibleOpenDelimiter(index: Int) -> Bool {
		if index == openDelimiters.count { // we successfully encountered a full delimiter sequence
			return true
		}
		if let e = next() {
			testingPutback!.append(e)
			if e == openDelimiters[index] {
				return consumePossibleOpenDelimiter(1 + index)
			}
		}
		return false
	}
	
	func consumePossibleCloseDelimiter(index: Int) -> Bool {
		if index == closeDelimiters.count { // we successfully encountered a full delimiter sequence
			return true
		}
		if let e = next() {
			if e == closeDelimiters[index] {
				testingPutback!.append(e)
				return consumePossibleCloseDelimiter(1 + index)
			}
		}
		return false
	}
	
	// Read until delimiters are encountered
	func consumeTag() throws -> MoustacheTagType {
		
		if let e = skipWhiteSpace() {
			// e is first non-white character
			// # ^ ! >
			switch e {
			
			case "%": // pragma
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustachePragmaTag()
				newTag.tag = tagName
				newTag.type = .Pragma
				addChild(newTag)
				pragmas.append(newTag)
				
			case "#": // group
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustacheGroupTag()
				newTag.tag = tagName
				newTag.type = .Hash
				addChild(newTag)
				activeList = newTag
				
			case "^": // inverted group
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustacheGroupTag()
				newTag.tag = tagName
				newTag.type = .Caret
				addChild(newTag)
				activeList = newTag
				
			case "!": // comment COULD discard but I add it for debugging purposes. skipped during eval
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustacheTag()
				newTag.tag = tagName
				newTag.type = .Bang
				addChild(newTag)
				
			case "&": // unescaped name
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustacheTag()
				newTag.tag = tagName
				newTag.type = .UnescapedName
				addChild(newTag)
				
			case ">": // partial
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustachePartialTag()
				newTag.tag = tagName
				newTag.type = .Partial
				addChild(newTag)
				
			case "/": // pop group. ensure names match
				let tagName = consumeTagName(skipWhiteSpace())
				guard tagName == activeList!.tag else {
					throw MoustacheError.SyntaxError("The closing tag /" + tagName + " did not match " + activeList!.tag)
				}
				activeList = activeList!.parent
			
			case "=": // set delimiters
				try consumeSetDelimiters()
			
			case "{": // unencoded name
				handlingUnencodedName = true
				let tagName = consumeTagName(skipWhiteSpace())
				let newTag = MoustacheTag()
				newTag.tag = tagName
				newTag.type = .UnencodedName
				addChild(newTag)
				guard !handlingUnencodedName else {
					throw MoustacheError.SyntaxError("The unencoded tag " + tagName + " did not proper closing delimiters")
				}
			default:
				let tagName = consumeTagName(e)
				let newTag = MoustacheTag()
				newTag.tag = tagName
				newTag.type = .Name
				addChild(newTag)
			}
		}
		return .Plain
	}
	
	// reads until closing delimiters
	// read and discard closing delimiters leaving us things at .Plain
	func consumeTagName() -> String {
		let s = ""
		return consumeTagName(s)
	}
	
	// reads until closing delimiters
	// firstChar was read as part of previous step and should be added to the result
	func consumeTagName(firstChar: UnicodeScalar?) -> String {
		
		guard let f = firstChar else {
			return ""
		}
		
		let s = String(f)
		return consumeTagName(s)
	}
	
	func consumeTagName(var s: String) -> String {
		
		while let e = next() {
			
			if handlingUnencodedName && e == "}" {
				handlingUnencodedName = false
				continue
			}
			
			if e == closeDelimiters[0] {
				testingPutback = String(e)
				if consumePossibleCloseDelimiter(1) {
					break
				}
				s.appendContentsOf(testingPutback!)
			} else {
				s.append(e)
			}
		}
		var scalars = s.unicodeScalars
		var idx = scalars.endIndex.predecessor()
		
		while ICU.isWhiteSpace(scalars[idx]) {
			scalars.removeAtIndex(idx)
			idx = idx.predecessor()
		}
		
		return String(scalars)
	}
	
	func skipWhiteSpace() -> UnicodeScalar? {
		var e = next()
		while e != nil {
			if !ICU.isWhiteSpace(e!) {
				return e
			}
			e = next()
		}
		return e
	}
	
	func consumeSetDelimiters() throws {
		let errorMsg = "Syntax error while setting delimiters"
		var e = skipWhiteSpace()
		if e != nil {
			
			var openD = String(e!)
			// read until a white space
			while true {
				
				e = next()
				if e != nil && !ICU.isWhiteSpace(e!) {
					openD.append(e!)
				} else {
					break
				}
			}
			
			guard e != nil && ICU.isWhiteSpace(e!) else {
				throw MoustacheError.SyntaxError(errorMsg)
			}
			
			e = skipWhiteSpace()
			
			guard e != nil && !ICU.isWhiteSpace(e!) else {
				throw MoustacheError.SyntaxError(errorMsg)
			}
			
			var closeD = String(e!)
			// read until a =
			while true {
				
				e = next()
				if e != nil && !ICU.isWhiteSpace(e!) && e! != "=" {
					closeD.append(e!)
				} else {
					break
				}
			}
			
			if e != nil && ICU.isWhiteSpace(e!) {
				e = skipWhiteSpace()
				guard e != nil && e! == "=" else {
					throw MoustacheError.SyntaxError(errorMsg)
				}
			}
			
			e = skipWhiteSpace()
			guard e != nil else {
				throw MoustacheError.SyntaxError(errorMsg)
			}
			guard e! == closeDelimiters[0] && consumePossibleCloseDelimiter(1) else {
				throw MoustacheError.SyntaxError(errorMsg)
			}
			
			setDelimiters(Array(openD.unicodeScalars), close: Array(closeD.unicodeScalars))
		}
	}
	
	func setDelimiters(open: [UnicodeScalar], close: [UnicodeScalar]) {
		openDelimiters = open
		closeDelimiters = close
	}
}






